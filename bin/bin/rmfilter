#!/usr/bin/env bun
/// <reference types="bun-types" />
import { $ } from 'bun';
import { tmpdir } from 'node:os';
import path from 'node:path';
import { packageUp } from 'package-up';
import { chdir } from 'process';
import { parseArgs } from 'util';
import * as changeCase from 'change-case';
import os from 'node:os';

let { values, positionals } = parseArgs({
  options: {
    packages: {
      type: 'string',
      multiple: true,
      short: 'p',
    },
    upstream: {
      type: 'string',
      multiple: true,
      short: 'u',
    },
    downstream: {
      type: 'string',
      short: 'd',
      multiple: true,
    },
    both: {
      type: 'string',
      short: 'b',
      multiple: true,
    },
    grep: {
      type: 'string',
      short: 'g',
      multiple: true,
    },
    'grep-package': {
      type: 'string',
      short: 'G',
      multiple: true,
    },
    'whole-word': {
      type: 'boolean',
      short: 'w',
    },
    instructions: {
      type: 'string',
      short: 'i',
    },
    expand: {
      type: 'boolean',
      short: 'e',
    },
    architect: {
      type: 'boolean',
      short: 'a',
    },
    output: {
      type: 'string',
      short: 'o',
    },
    copy: {
      type: 'boolean',
      short: 'c',
    },
    help: {
      type: 'boolean',
      short: 'h',
    },
  },
  allowPositionals: true,
  allowNegative: true,
});

if (values.help) {
  console.log('usage: rmfilter.ts <packages>');
  console.log();
  console.log('Options:');
  console.log('  -p, --packages <packages>   Include the contents of these packages');
  console.log('  -u, --upstream <packages>   Include this packages and its dependencies');
  console.log('  -d, --downstream <packages> Include this package and its dependents');
  console.log(
    '  -b, --both <packages>       Include the package and its upstream and downstream dependencies'
  );
  console.log('  -g, --grep <patterns>       Include files that match this pattern');
  console.log(
    '  -G, --grep-package <pkg>    Include all packages with a file that matches ths pattern'
  );
  console.log(
    '  -e, --expand                Expand search terms to include snake case, camel case, etc.'
  );
  console.log('  -w, --whole-word            Match whole words only');
  console.log('  -a, --architect             Enable architect mode (removes empty lines)');
  console.log('  -i, --instructions          Add instructions to the prompt, prefix with @ to indicate a file.');
  console.log('  -o, --output <file>         Specify the output file');
  console.log('  -c, --copy                  Copy the output file to the clipboard');
  console.log('  -h, --help                  Show this help message and exit');
  process.exit(0);
}

const gitRoot = (await $`git rev-parse --show-toplevel`.text()).trim();
chdir(gitRoot);

async function getDeps(packages: string[] | undefined, mode: 'upstream' | 'downstream' | 'only') {
  if (!packages?.length) {
    return [];
  }

  packages = packages.flatMap((p) => p.split(','));

  let args = packages.flatMap((pkg) => {
    let filter: string;
    if (mode === 'upstream') {
      filter = `${pkg}...`;
    } else if (mode === 'downstream') {
      filter = `...${pkg}`;
    } else {
      filter = pkg;
    }
    return ['-F', filter];
  });

  let proc = Bun.spawn(['turbo', 'ls', '--output', 'json', ...args]);
  let output = await new Response(proc.stdout).json();

  return output.packages.items.map((p) => p.path);
}

function expandPattern(pattern: string) {
  return [changeCase.snakeCase(pattern), changeCase.camelCase(pattern)];
}

let repomixIgnoreExistsPromise: Promise<boolean> | undefined;
async function useRepomixIgnore() {
  repomixIgnoreExistsPromise ??= Bun.file(path.join(gitRoot, '.repomixignore')).exists();
  return repomixIgnoreExistsPromise;
}

async function grepFor(patterns: string[] | undefined, mode: 'file' | 'package') {
  if (!patterns?.length) {
    return [];
  }

  patterns = patterns.flatMap((p) => p.split(','));

  if (values.expand) {
    patterns = patterns.flatMap(expandPattern);
  }

  let args = patterns.flatMap((pattern) => ['-e', pattern]);
  if (await useRepomixIgnore()) {
    args.push('--ignore-file=.repomixignore');
  }

  if (values['whole-word']) {
    args.push('--word-regexp');
  }

  let proc = Bun.spawn(['rg', '-i', '--files-with-matches', ...args]);
  let results = await new Response(proc.stdout).text();

  let files = results
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean);

  if (mode === 'file') {
    return files;
  }

  let packagePaths = await Promise.all(
    files.map((file) =>
      packageUp({
        cwd: path.dirname(file),
      })
    )
  );

  let packageDirs = new Set(
    packagePaths
      .map((p) => {
        if (!p) {
          return;
        }

        let dir = path.dirname(p);
        let relDir = path.relative(gitRoot, dir);
        if (relDir === '') {
          return;
        }

        return relDir;
      })
      .filter((p) => p != null)
  );

  return [...packageDirs];
}

let upstream = [...(values.upstream ?? []), ...(values.both ?? [])];
let downstream = [...(values.downstream ?? []), ...(values.both ?? [])];

if (
  !upstream.length &&
  !downstream.length &&
  !values.packages?.length &&
  !values.grep?.length &&
  !values['grep-package']?.length
) {
  console.log('no packages or grep strings specified');
  process.exit(0);
}

let pathsSet = new Set(
  (
    await Promise.all([
      getDeps(upstream, 'upstream'),
      getDeps(downstream, 'downstream'),
      getDeps(values.packages, 'only'),
      grepFor(values.grep, 'file'),
      grepFor(values['grep-package'], 'package'),
    ])
  ).flat()
);

let allPaths = Array.from(pathsSet).join(',');

// Add architect mode arguments if enabled
const architectArgs = values.architect ? ['--remove-empty-lines'] : [];

// Capture repomix output
const tempFile = path.join(tmpdir(), `repomix-${Math.random().toString(36).slice(2)}.txt`);
let proc = Bun.spawn(
  ['repomix', '--ignore', '*.sql', '--include', allPaths, ...architectArgs, ...positionals, '-o', tempFile],
  {
    stdout: 'inherit',
    stderr: 'inherit',
  }
);
const exitCode = await proc.exited;
if (exitCode !== 0) {
  console.error(`repomix exited with code ${exitCode}`);
  process.exit(exitCode);
}

// Read the temporary file contents
const repomixOutput = await Bun.file(tempFile).text();
await Bun.file(tempFile).unlink();

// Handle instructions
let instructionsTag = '';
if (values.instructions) {
  let instructionsContent;
  if (values.instructions.startsWith('@')) {
    const instructionFile = values.instructions.slice(1);
    try {
      instructionsContent = await Bun.file(instructionFile).text();
    } catch (error) {
      console.error(`Error reading instructions file: ${instructionFile}`);
      process.exit(1);
    }
  } else {
    instructionsContent = values.instructions;
  }
  instructionsTag = `\n<instructions>\n${instructionsContent}\n</instructions>`;
}

async function copyToClipboard(text: string) {
  let command: string[];
  if (process.platform === 'darwin') {
    // macOS
    command = ['pbcopy'];
  } else if (process.platform === 'win32') {
    // Windows
    command = ['clip'];
  } else {
    // Linux: try wl-copy (Wayland) or xclip (X11)
    const hasWlCopy = await $`command -v wl-copy`.quiet().then(() => true).catch(() => false);
    if (hasWlCopy) {
      command = ['wl-copy'];
    } else {
      const hasXclip = await $`command -v xclip`.quiet().then(() => true).catch(() => false);
      if (hasXclip) {
        command = ['xclip', '-selection', 'clipboard'];
      } else {
        console.warn('No clipboard utility found (install wl-copy or xclip on Linux)');
        return;
      }
    }
  }
  const proc = Bun.spawn(command, {
    stdin: 'pipe',
    stdout: 'inherit',
    stderr: 'inherit',
  });
  proc.stdin!.write(text);
  await proc.stdin!.end();
  const exitCode = await proc.exited;
  if (exitCode === 0) {
    console.log('Output copied to clipboard');
  } else {
    console.warn(`Failed to copy to clipboard (exit code: ${exitCode})`);
  }
}

// Determine output file
let outputFile;
if (values.output) {
  outputFile = values.output;
} else {
  const configPath = path.join(os.homedir(), '.config', 'repomix', 'repomix.config.json');
  if (await Bun.file(configPath).exists()) {
    try {
      const config = await Bun.file(configPath).json();
      outputFile = config.output?.filePath;
    } catch (error) {
      console.error(`Error reading config file: ${configPath}`);
    }
  }
  if (!outputFile) {
    outputFile = './repomix_output.txt';
  }
}

// Write final output
const finalOutput = repomixOutput + instructionsTag;
await Bun.write(outputFile, finalOutput);
console.log(`Output written to ${outputFile}`);

if(values.copy) {
  await copyToClipboard(finalOutput);
}
